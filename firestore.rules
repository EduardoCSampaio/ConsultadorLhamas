/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a role-based access control model with user-owned data and team-based permissions.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible only to the user and admins.
 * - /teams/{teamId}: Stores team data, accessible to team managers and admins.
 * - /activityLogs/{logId}: Stores activity logs, readable by admins for auditing.
 * - /batches/{batchId}: Stores batch job details, accessible to the user who created the batch and admins.
 * - /cltConsents/{consentId}: Stores CLT consent terms, accessible to the user who created them and admins.
 * - /tickets/{ticketId}: Stores support tickets. Users can only access their own tickets. Admins can access all tickets.
 * - /tickets/{ticketId}/messages/{messageId}: Stores ticket messages. Access follows the ticket's access rules.
 * - /webhookResponses/{responseId}: Stores API responses, publicly accessible for read.
 * - /users/{userId}/notifications/{notificationId}: Stores user-specific notifications. Only the user can access their own notifications.
 *
 * Key Security Decisions:
 * - Strict user ownership for profile data and created content (batches, consents, tickets).
 * - Role-based access control (super_admin, manager, user) for administrative functions.
 * - Webhook responses are publicly readable but writes are disabled for security.
 * - Listing of users is disallowed.
 *
 * Denormalization for Authorization:
 * - Team documents store the manager's UID in the `managerId` field to simplify ownership checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @principle Verified Identity: All authorization decisions must rely on `request.auth`.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     * @param {string} userId The user ID to check against.
     * @principle Ownership: Enforces that only the owner can modify or delete their own data.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is an existing owner of the resource.
     * @param {string} userId The user ID to check against.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

     /**
     * @description Checks if the authenticated user has the 'super_admin' role.
     * @principle Roles: Grants elevated privileges to admin users.
     */
    function isSuperAdmin() {
      return isSignedIn() && (request.auth.token.super_admin == true);
    }
      /**
     * @description Checks if the authenticated user has the 'admin' role.
     * @principle Roles: Grants elevated privileges to admin users.
     */
    function isAdmin() {
      return isSignedIn() && (request.auth.token.admin == true);
    }


    /**
     * @description Manages access to user profile information.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' creates their own profile.
     * @allow (get, update, delete) User with UID 'user123' reads/updates/deletes their own profile.
     * @allow (get) Admin reads any user profile.
     * @deny (create) User attempts to create a profile with a mismatched UID.
     * @deny (update, delete) User attempts to modify another user's profile.
     * @deny (list) Listing users is not allowed.
     * @principle Ownership: Enforces strict user ownership for profile data.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isSuperAdmin() || isAdmin();
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages access to team information.
     * @path /teams/{teamId}
     * @allow (create) Admin creates a new team.
     * @allow (get, update, delete) Team manager or admin manages team details.
     * @deny (create, update, delete) Regular user attempts to modify team data.
     * @deny (list) Public team listing is not allowed.
     * @principle Roles: Restricts team management to authorized personnel.
     */
    match /teams/{teamId} {
        allow get: if isSuperAdmin() || isAdmin() || request.auth.uid == resource.data.managerId;
        allow list: if false;
        allow create: if isSuperAdmin() || isAdmin();
        allow update: if (isSuperAdmin() || isAdmin() || request.auth.uid == resource.data.managerId) && resource != null;
        allow delete: if isSuperAdmin() || isAdmin() && resource != null;
    }

    /**
     * @description Manages access to activity logs.
     * @path /activityLogs/{logId}
     * @allow (get, list) Admin reads activity logs for auditing purposes.
     * @deny (create, update, delete) Regular users cannot modify activity logs.
     * @principle Roles: Restricts access to sensitive audit data to administrators.
     */
    match /activityLogs/{logId} {
      allow get, list: if isSuperAdmin() || isAdmin();
      allow create, update, delete: if false;
    }

    /**
     * @description Manages access to batch processing job information.
     * @path /batches/{batchId}
     * @allow (create, get, update, delete) User who created the batch can manage it. Admins can also manage all batches.
     * @deny (create, update, delete) Regular users cannot modify other users' batches.
     * @deny (list) Public listing of batches is not allowed.
     * @principle Ownership: Enforces user ownership for batch jobs.
     */
    match /batches/{batchId} {
      allow get: if isOwner(resource.data.userId) || isSuperAdmin() || isAdmin();
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if (isExistingOwner(resource.data.userId) || isSuperAdmin() || isAdmin()) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(resource.data.userId) || isSuperAdmin() || isAdmin();
    }

    /**
     * @description Manages access to CLT consent terms.
     * @path /cltConsents/{consentId}
     * @allow (create, get, update, delete) User who created the consent can manage it. Admins can also manage all consents.
     * @deny (create, update, delete) Regular users cannot modify other users' consents.
     * @deny (list) Public listing of consents is not allowed.
     * @principle Ownership: Enforces user ownership for CLT consent terms.
     */
    match /cltConsents/{consentId} {
      allow get: if isOwner(resource.data.userId) || isSuperAdmin() || isAdmin();
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if (isExistingOwner(resource.data.userId) || isSuperAdmin() || isAdmin()) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(resource.data.userId) || isSuperAdmin() || isAdmin();
    }

    /**
     * @description Manages access to support tickets.
     * @path /tickets/{ticketId}
     * @allow (create) Any signed-in user can create a ticket.
     * @allow (get, update) User can access and update their own tickets.
     * @allow (get, list) Admin can access and list all tickets.
     * @deny (update, delete) User cannot modify other users' tickets.
     * @principle Ownership: Enforces user ownership for support tickets.
     */
    match /tickets/{ticketId} {
      allow get: if isOwner(resource.data.userId) || isSuperAdmin() || isAdmin();
      allow list: if isSuperAdmin() || isAdmin();
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if (isExistingOwner(resource.data.userId) || isSuperAdmin() || isAdmin()) && request.resource.data.userId == resource.data.userId;
      allow delete: if false; // Deletion is generally not allowed for tickets.
    }

    /**
     * @description Manages access to ticket messages within a support ticket.
     * @path /tickets/{ticketId}/messages/{messageId}
     * @allow (create) Any signed-in user can create a message within a ticket they have access to.
     * @allow (get, list) User can access messages in their own tickets. Admin can access all messages.
     * @deny (update, delete) No updates or deletes on messages.
     * @principle Ownership: Message access is tied to the parent ticket's ownership.
     */
    match /tickets/{ticketId}/messages/{messageId} {
      allow get, list: if isOwner(get(/databases/$(database)/documents/tickets/$(ticketId)).data.userId) || isSuperAdmin() || isAdmin();
      allow create: if isSignedIn() && (isOwner(get(/databases/$(database)/documents/tickets/$(ticketId)).data.userId) || isSuperAdmin() || isAdmin());
      allow update, delete: if false;
    }

    /**
     * @description Manages access to webhook responses.
     * @path /webhookResponses/{responseId}
     * @allow (get, list) Public read access to all webhook responses.
     * @deny (create, update, delete) No writes allowed.
     * @principle Public Read: Allows public access for data consumption.
     */
    match /webhookResponses/{responseId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Manages access to user-specific notifications.
     * @path /users/{userId}/notifications/{notificationId}
     * @allow (create) Creating a notification is not allowed via client.
     * @allow (get, list) Only the user and admins can read their own notifications.
     * @deny (update, delete) Users cannot modify notifications.
     * @principle Ownership: Enforces user ownership for notifications.
     */
    match /users/{userId}/notifications/{notificationId} {
      allow get: if isOwner(userId) || isSuperAdmin() || isAdmin();
      allow list: if isOwner(userId) || isSuperAdmin() || isAdmin();
      allow create: if false;
      allow update, delete: if false;
    }
  }
}