/**
 * @file Firestore Security Rules
 * @core_philosophy This ruleset enforces a strict user-ownership model for personal data,
 * with additional controls for admin-level operations. Public read access is granted only
 * where explicitly intended and safe.
 * @data_structure Data is organized primarily around users (`/users/{userId}`), with
 * some top-level collections for shared resources and system-wide data.
 * @key_security_decisions
 *   - User listing is disallowed to prevent unauthorized data scraping.
 *   - Read-only collections are explicitly marked and allow public read access.
 *   - Ambiguous relationships default to owner-only access for maximum security.
 *   - Data required for authorization is denormalized onto the documents being secured.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows access to API responses.
     * @path /webhookResponses/{responseId}
     * @allow (read, write) if false; // TODO: Implement appropriate access control.
     * @deny (read, write) Always. Access control not yet defined.
     * @principle Access control for webhook responses is not defined.
     */
    match /webhookResponses/{responseId} {
      allow get, list: if false;
      allow create, update, delete: if false; // TODO: Implement appropriate access control.
    }

    /**
     * @description Manages user profiles. Users can only read/write their own profile.
     * @path /users/{userId}
     * @allow (create) User creates their own profile if the UID matches.
     * @allow (get, update, delete) User can only read, update, or delete their own profile.
     * @deny (create) if the user tries to create a profile with a mismatched UID.
     * @deny (get, update, delete) if a different user tries to access this profile.
     * @principle Enforces user-ownership for profile data.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isNewOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if false; // Delete operation is not allowed.
    }

      /**
       * @description Manages team information. Manager can read/write their own team info
       * @path /teams/{teamId}
       * @allow (create) Manager creates their own team if the managerId matches
       * @allow (get, update) Manager can only read, update their own team information
       * @deny (create) if the user tries to create a team with a mismatched managerId.
       * @deny (get, update) if a different user tries to access this team
       * @principle Enforces user-ownership for team data.
       */
      match /teams/{teamId} {
        allow get, list: if true;
        allow create: if isSignedIn();
        allow update: if isSignedIn();
        allow delete: if false; // Delete operation is not allowed.
      }

    /**
     * @description Allows access to activity logs.
     * @path /activityLogs/{logId}
     * @allow (read, write) if false; // TODO: Implement appropriate access control.
     * @deny (read, write) Always. Access control not yet defined.
     * @principle Access control for activity logs is not defined.
     */
    match /activityLogs/{logId} {
      allow get, list: if false;
      allow create, update, delete: if false; // TODO: Implement appropriate access control.
    }

    /**
     * @description Allows access to batch jobs.
     * @path /batches/{batchId}
     * @allow (read, write) if false; // TODO: Implement appropriate access control.
     * @deny (read, write) Always. Access control not yet defined.
     * @principle Access control for batch jobs is not defined.
     */
    match /batches/{batchId} {
      allow get, list: if false;
      allow create, update, delete: if false; // TODO: Implement appropriate access control.
    }

    /**
     * @description Allows access to clt consents.
     * @path /cltConsents/{consentId}
     * @allow (read, write) if false; // TODO: Implement appropriate access control.
     * @deny (read, write) Always. Access control not yet defined.
     * @principle Access control for clt consents is not defined.
     */
    match /cltConsents/{consentId} {
      allow get, list: if false;
      allow create, update, delete: if false; // TODO: Implement appropriate access control.
    }

    /**
     * @description Allows access to support tickets.
     * @path /tickets/{ticketId}
     * @allow (read, write) if false; // TODO: Implement appropriate access control.
     * @deny (read, write) Always. Access control not yet defined.
     * @principle Access control for support tickets is not defined.
     */
    match /tickets/{ticketId} {
      allow get, list: if false;
      allow create, update, delete: if false; // TODO: Implement appropriate access control.
    }

    /**
     * @description Allows access to ticket messages.
     * @path /tickets/{ticketId}/messages/{messageId}
     * @allow (read, write) if false; // TODO: Implement appropriate access control.
     * @deny (read, write) Always. Access control not yet defined.
     * @principle Access control for ticket messages is not defined.
     */
    match /tickets/{ticketId}/messages/{messageId} {
      allow get, list: if false;
      allow create, update, delete: if false; // TODO: Implement appropriate access control.
    }

    /**
     * @description Manages user-specific notifications. Users can only access their own notifications.
     * @path /users/{userId}/notifications/{notificationId}
     * @allow (create) if the user is creating a notification for themself.
     * @allow (get, list, update, delete) if the user owns the notification.
     * @deny (create, get, list, update, delete) if a different user tries to access these notifications.
     * @principle Enforces user-ownership for notification data.
     */
    match /users/{userId}/notifications/{notificationId} {
      allow get, list: if isOwner(userId);
      allow create: if request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Defines helper functions for access control.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isNewOwner(userId) {
        return (request.auth.uid == userId) && (request.resource.data.uid == request.auth.uid);
    }

   function isExistingOwner(userId) {
        return (request.auth.uid == userId) && (resource != null);
    }
  }
}